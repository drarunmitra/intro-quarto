<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Communicating Research with RMarkdown</title>
    <meta charset="utf-8" />
    <meta name="author" content="   Dr. Arun Mitra" />
    <meta name="date" content="2021-10-23" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Communicating Research with RMarkdown
## Day 3: Session 1 <br> Data Analysis Using R Workshop
### <img src="https://i.ibb.co/BVhGyMV/RIntro2021-new.png" /> <br> Dr. Arun Mitra
### AMCHSS, SCTIMST
### 2021-10-23

---





.top[# What is RMarkdown?]

.middle[
### RMarkdown is a file format for making dynamic documents with R. 


### An R Markdown document is written in markdown (an easy-to-write plain text format) and contains chunks of embedded R code


### R Markdown provides an unified authoring framework for data science, combining your code, its results, and your prose commentary. 


### R Markdown documents are fully reproducible and support dozens of output formats, like PDFs, Word files, slideshows, and more.

]

---
class: middle

.top[# What is RMarkdown?]

.center[![:scale 90%](fig1.jpg)]

---

# Need some help?

- ### R Markdown Cheat Sheet: 
`Help &gt; Cheatsheets &gt; R Markdown Cheat Sheet`

- ### R Markdown Reference Guide: 
`Help &gt; Cheatsheets &gt; R Markdown Reference Guide`


You need the `rmarkdown package`, however it is automatically loaded by RStudio.


To create a new RMarkdown file (`.Rmd`), select *File -&gt; New File -&gt; R Markdown* in RStudio, then choose the file type you want to create. 

For now we will focus on a `.html` Document, which can be easily converted to other file types later.



---

class: middle

.top[# Components of an RMarkdown file]


It contains three important types of content:

- An (optional) YAML header surrounded by `---`


- Chunks of R code surrounded by ` ``` `


- Text mixed with formatting like `##` headings and simple text.

.center[![:scale 90%](structure.JPG)]


---

# YAML Header

### Defines the metadata

### Defines the output format

### Defines options of the output format



```md
---
title: "First Example"
author: "Arun Mitra"
date: "23/10/2021"
output: html_document
        toc : true
---

```

---
class: middle

.top[# Markdown is Cool]

.center[![:scale 90%](markdown_demo.gif)]

---

class: middle

.top[# Basic Markdown Syntax]

.center[![:scale 90%](basics_markdown_syntax.png)]


---
class: middle

# Code Chunks 

The knitr package extends the basic markdown syntax to include chunks of executable R code.

When you render the report, knitr will run the code and add the results to the output file. You can have the output display just the code, just the results, or both.

To embed a chunk of R code into your report, surround the code with two lines that each contain three back ticks. After the first set of back ticks, include ` ```{` `r` `}`, which alerts knitr that you have included a chunk of R code. 
---
class: middle

.top[# R Chunks]

.center[![:scale 90%](rchunk1.jpg)]


---
class:middle

# Chunk Options

### To omit the results

To omit the results from your final report (and not run the code) add the argument `eval = FALSE` inside the brackets and after `r`. This will place a copy of your code into the report.


### To omit the code

To omit the code from the final report (while including the results) add the argument `echo = FALSE`. This is very handy for adding plots to a report, since you usually do not want to see the code that generates the plot.
---

class: middle

.top[# R Chunks]

.center[![:scale 90%](rchunk2.jpg)]


---

class: middle

.top[# R Chunks]

.center[![:scale 90%](rchunk3.jpg)]


---



# Inline R Code

You can also evaluate R expressions inline by enclosing the expression within a single back-tick qualified with `r`. 



`knitr` will replace the inline code with its result in your final document (inline code is always replaced by its result). The result will appear as if it were part of the original text.



.center[![:scale 70%](inline.jpg)]


---


class: middle

.top[# Default RMD output in HTML]

.center[![:scale 50%](default_rmd_output.jpg)]


---



class: middle

.top[# Other Outputs]

.center[![:scale 60%](rmd_outputs.png)]


---

class: middle

.center[![:scale 100%](others.JPG)]


---
class: center middle

.center[![:scale 100%](rmarkdown1.png)]

---

# Conclusion


### R Markdown is awesome. 

- The ratio of markup to content is excellent. 

- For exploratory analyses, blog posts, and interactive documents

- For journal articles, though knowledge on `\(\LaTeX\)` will  be helpful.

### The RStudio team have made the whole process very user friendly.

- RStudio provides useful shortcut keys for compiling to HTML, and running code chunks. 

- These shortcut keys are presented in a clear way.

- Code completion on R code chunk options is really helpful. 
    

---


class: center middle



&lt;img src="rmd_1.JPG" width="120%" style="display: block; margin: auto;" /&gt;

---

class: middle center

# Questions?
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "solarized-dark",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "4:3"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<style>
.logo {
  background-image: url(RIntro2021.png);
  background-size: contain;
  background-repeat: no-repeat;
  position: absolute;
  top: 1em;
  right: 1em;
  width: 50px;
  height: 50px;
  z-index: 0;
}
</style>

<script>
document
  .querySelectorAll(
    '.remark-slide-content' +
    ':not(.title-slide)' +
    // add additional classes to exclude here, e.g.
    ':not(.inverse)' +
    ':not(.hide-logo)'
  )
  .forEach(el => {
    el.innerHTML += '<div class="logo"></div>';
  });
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
